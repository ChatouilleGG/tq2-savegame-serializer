<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Chatouille">
<title>tq2-savegame-serializer(sample)</title>
<!--<link rel="icon" type="image/svg" href="img/favicon.svg"/>-->

<!-- SYNTAX HIGHLIGHTER -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/stackoverflow-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>

<style>
* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

html, body {
	position: fixed;
	width: 100vw;
	height: 100vh;
	font-family: system-ui;
	background: #324;
	color: #ddd;
}

body {
	padding: 1em;
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	&.drop { box-shadow: inset 0 0 20px 10px lime; }
}

body > *+* { margin-top: 1em; }

h1 { font-weight: 300; }

label {
	display: flex;
	align-items: center;
}

input[type="checkbox"] {
	width: 1.4em;
	height: 1.4em;
	margin-right: 0.5em;
}

pre {
	width: 100%;
	flex: 1 1 0;
	overflow: auto;
	tab-size: 2em;
}
code {
	height: 100%;
}
</style>
<body>

<h1>TQ2 Savegame Serializer - Sample Web Integration</h1>
<input type="file" onchange="onFile(this.files[0])" accept=".sav"/>
<div style="width:100%;display:flex;align-items:center">
	<label><input type="checkbox" id="cbShowReflection" onchange="renderJson()"/>Show reflection data</label>
	<label style="margin-left:2em"><input type="checkbox" id="cbHljs" onchange="renderHljs()" checked/>Syntax highlighting</label>
	<div style="flex-grow:1"></div>
	<button type="button" style="padding:0.3em 0.6em" onclick="resave()">Resave</button>
</div>
<pre><code id="view" class="language-json" contenteditable="true" spellcheck="false"></code></pre>

<script src="./serializer.js" referrerpolicy="no-referrer"></script>
<script type="text/javascript">

let codeView;

document.addEventListener('DOMContentLoaded', () => {
	codeView = document.getElementById('view');

	let hlTimeout;
	document.addEventListener('dragenter', (event) => {
		event.preventDefault();
		//if (event.dataTransfer.items[0].type.match(/\.sav$/i))
			document.body.classList.add('drop');
	});
	document.addEventListener('dragover', (event) => {
		event.preventDefault();
		document.body.classList.add('drop');
	});
	document.addEventListener('dragleave', (event) => {
		event.preventDefault();
		document.body.classList.remove('drop');
	});
	document.addEventListener('drop', (event) => {
		event.preventDefault();
		document.body.classList.remove('drop');

		if (event.dataTransfer.items) {
			let item = event.dataTransfer.items[0];
			if (item.kind === 'file' )//&& item.type.match(/\.sav$/i))
				onFile(item.getAsFile());
		}
		else {
			let file = event.dataTransfer.files[0];
			if (file)// && file.type.match(/\.sav$/i))
				onFile(file);
		}
		return false;
	});
});

function onFile(file) {
	if (file && file.name.endsWith('.sav')) {
		fileName = file.name;
		const reader = new FileReader();
		reader.onload = function(event) {
			if (event.target.readyState == FileReader.DONE)
				onBuffer(event.target.result);
		};
		reader.onerror = onError;
		reader.readAsArrayBuffer(file);
	}
	else
		onError("Expected a .sav file type");
}

let fileData = null;
let fileName = "Unnamed.sav";

function onBuffer(buf) {
	try {
		let reader = new TQ2SS.UReader(buf);
		fileData = reader.File_Data_Player();
		renderJson();
		if (!reader.isEOF())
			throw new Error("Deserialization complete but reader has not reached end-of-file");
	}
	catch(err) { onError(err); }
}

function renderJson() {
	if (!fileData)
		return;

	TQ2SS.Options.JsonSkipReflection = !document.getElementById('cbShowReflection').checked;

	codeView.innerHTML = TQ2SS.ToJson(fileData);

	setTimeout(renderHljs, 1);
}

//TODO: Highlighting performance is abysmal when doing large edits (remove block, paste block)
// We should try to detect when big changes are made (Ctrl+V or Delete/Input with a big selection range)
// and automatically disable highlighting before doing the operation

function renderHljs() {
	let enabled = document.getElementById('cbHljs').checked;

	if (enabled) {
		codeView.setAttribute('data-highlighted','');
		hljs.highlightAll();
	}
	else {
		codeView.setAttribute('data-highlighted','');
		let json = codeView.innerText;
		codeView.innerHTML = json;
	}
}

function resave() {
	try {
		let json = codeView.innerText;
		let newData = JSON.parse(json);

		if (TQ2SS.Options.JsonSkipReflection)
			mergePropertyTags(fileData, newData);

		let writer = new TQ2SS.UWriter();
		writer.File_Data_Player(newData);

		let blob = new Blob([writer.getBuffer()], { type:'application/octet-stream' });
		let url = URL.createObjectURL(blob);

		let link = document.createElement('a');
		link.href = url;
		link.download = fileName;
		document.body.appendChild(link);
		link.click();

		setTimeout(() => {
			link.remove();
			URL.revokeObjectURL(url);
		}, 1);
	}
	catch(err) {
		onError(err);
	}
}

function mergePropertyTags(source, dest) {
	if (typeof(dest) != typeof(source) && dest !== undefined && source !== undefined)
		throw new Error("Type mismatch for property '"+propName+"' - dest is "+typeof(dest)+" but source is "+typeof(source));

	// Nothing to merge if one of those is true
	if (typeof(dest) != 'object' || typeof(source) != 'object' || !dest || !source)
		return;

	if (dest instanceof Array) {
		if (!(source instanceof Array))
			throw new Error("Type mismatch for property '"+propName+"' - dest is Array but source is Object");

		// NOTE: This is a basic system, will not support significant changes.
		// When it comes to array of structs, the struct items may have varying property tags (since only non-defaults are serialized).
		// If we remove an element from the array, we have no guarantee we'll find the right tags to import from source item at the modified index.
		// Adding an array element that contains reflection data is obviously also not supported by the merger.
		for (let i=0; i<dest.length; i++)
			mergePropertyTags(source[i], dest[i]);
		return;
	}

	if (source instanceof Array)
		throw new Error("Type mismatch for property '"+propName+"' - dest is Object but source is Array");

	const props = TQ2SS.Options.PropertiesKey;
	if (source[props]) {
		let remainingProps = Object.keys(dest);
		dest[props] = [];
		for (let tag of source[props]) {
			// Only add tag if present in destination
			if (dest[tag.Name] !== undefined)
				dest[props].push(tag);

			remainingProps.splice(remainingProps.indexOf(tag.Name), 1);
		}
		if (remainingProps.length > 0)
			throw new Error("Could not find property tag(s) for "+remainingProps.join(", "));
	}

	// Recurse
	for (let propName in dest) {
		if (propName != props)
			mergePropertyTags(source[propName], dest[propName]);
	}
}

function onError(err) {
	console.error(err);
	alert(err);
}

</script>

</body>
</html>