<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Chatouille">
<title>tq2-savegame-serializer(demo)</title>
<link rel="icon" type="image/webp" href="favicon.webp"/>

<!-- SYNTAX HIGHLIGHTER -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/stackoverflow-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>

<style>
* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
	align-items: center;
}

html, body {
	position: fixed;
	width: 100vw;
	height: 100vh;
	font-family: system-ui;
	background: #324;
	color: #ddd;
}

body {
	padding: 1em;
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	&.drop { box-shadow: inset 0 0 20px 10px lime; }
}

body > *+* { margin-top: 1em; }

h1 { font-weight: 300; }

label { display: flex; }

input[type="checkbox"] {
	width: 1.4em;
	height: 1.4em;
	margin-right: 0.5em;
}

pre {
	width: 100%;
	flex: 1 1 0;
	overflow: auto;
	tab-size: 2em;
}
code {
	height: 100%;
}

#codeView, #plainView {
	position: absolute;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
}
#plainView:not(.visible) {
	background: transparent;
	color: transparent;
	caret-color: white;
}
</style>
<body>

<div style="width:100%;display:flex">
	<img src="favicon.webp" style="height:3em;margin-right:0.5em;"/>
	<h1>TQ2 Savegame Serializer - Demo</h1>
	<div style="flex-grow:1"></div>
	<a href="https://github.com/ChatouilleGG/tq2-savegame-serializer" target="_blank" style="color:#09f;display:flex;text-decoration:none"><img src="https://github.githubassets.com/favicons/favicon-dark.png" style="height:1.4em;filter:brightness(0.5)sepia(1)saturate(50)hue-rotate(190deg)"/>&nbsp;github</a>
</div>
<input type="file" onchange="onFile(this.files[0])" accept=".sav"/>
<div style="width:100%;display:flex">
	<label><input type="checkbox" id="cbShowReflection" onchange="renderJson()"/>Show reflection data</label>
	<label style="margin-left:2em"><input type="checkbox" id="cbHljs" onchange="renderHljs()" checked/>Syntax highlighting</label>
	<div style="flex-grow:1"></div>
	<button type="button" style="padding:0.3em 0.6em" onclick="resave()">Resave</button>
</div>
<pre style="position:relative">
	<code id="codeView" class="hljs language-json"></code>
	<code id="plainView" class="hljs" contenteditable="true" spellcheck="false"></code>
</pre>

<script src="./serializer.js" referrerpolicy="no-referrer"></script>
<script type="text/javascript">

let cbHljs, cbShowReflection, codeView, plainView;

const TYPING_HIGHLIGHT_DELAY = 1000;

document.addEventListener('DOMContentLoaded', () => {
	cbHljs = document.getElementById('cbHljs');
	cbShowReflection = document.getElementById('cbShowReflection');
	codeView = document.getElementById('codeView');
	plainView = document.getElementById('plainView');

	// Improve editing performance by shadowing a plain text view, applying highlight with a delay when editing
	let restoreHljsTimeout;
	plainView.addEventListener('scroll', () => {
		// Shadow scrolling
		codeView.scrollTop = plainView.scrollTop;
		codeView.scrollLeft = plainView.scrollLeft;
	});
	plainView.addEventListener('input', () => {
		// Plain view takes over while editing, no point in keeping the shadow view updated until highlighting
		plainView.classList.add('visible');
		clearTimeout(restoreHljsTimeout);
		restoreHljsTimeout = setTimeout(renderHljs, TYPING_HIGHLIGHT_DELAY);
	});

	// Drag & drop file
	document.addEventListener('dragenter', (event) => {
		event.preventDefault();
		//if (event.dataTransfer.items[0].type.match(/\.sav$/i))
			document.body.classList.add('drop');
	});
	document.addEventListener('dragover', (event) => {
		event.preventDefault();
		document.body.classList.add('drop');
	});
	document.addEventListener('dragleave', (event) => {
		event.preventDefault();
		document.body.classList.remove('drop');
	});
	document.addEventListener('drop', (event) => {
		event.preventDefault();
		document.body.classList.remove('drop');

		if (event.dataTransfer.items) {
			let item = event.dataTransfer.items[0];
			if (item.kind === 'file' )//&& item.type.match(/\.sav$/i))
				onFile(item.getAsFile());
		}
		else {
			let file = event.dataTransfer.files[0];
			if (file)// && file.type.match(/\.sav$/i))
				onFile(file);
		}
		return false;
	});
});

function onFile(file) {
	if (file && file.name.endsWith('.sav')) {
		fileName = file.name;
		const reader = new FileReader();
		reader.onload = function(event) {
			if (event.target.readyState == FileReader.DONE)
				onBuffer(event.target.result);
		};
		reader.onerror = onError;
		reader.readAsArrayBuffer(file);
	}
	else
		onError("Expected a .sav file type");
}

let fileData = null;
let fileName = "Unnamed.sav";

function onBuffer(buf) {
	try {
		let reader = new TQ2SS.UReader(buf);
		fileData = reader.File_Data_Player();
		renderJson();
		if (!reader.isEOF())
			throw new Error("Deserialization complete but reader has not reached end-of-file");
	}
	catch(err) { onError(err); }
}

function renderJson() {
	if (!fileData)
		return;

	TQ2SS.Options.JsonSkipReflection = !cbShowReflection.checked;

	plainView.innerHTML = TQ2SS.ToJson(fileData);

	setTimeout(renderHljs, 1);
}

function renderHljs() {
	codeView.setAttribute('data-highlighted','');
	if (cbHljs.checked) {
		codeView.innerHTML = plainView.innerHTML;
		plainView.classList.remove('visible');
		// let a frame happen before the highlighting hiccup
		setTimeout(hljs.highlightElement, 1, codeView);
	}
	else
		plainView.classList.add('visible');
}

function resave() {
	try {
		let json = plainView.innerText;
		let newData = JSON.parse(json);

		if (TQ2SS.Options.JsonSkipReflection)
			mergePropertyTags(fileData, newData);

		let writer = new TQ2SS.UWriter();
		writer.File_Data_Player(newData);

		let blob = new Blob([writer.getBuffer()], { type:'application/octet-stream' });
		let url = URL.createObjectURL(blob);

		let link = document.createElement('a');
		link.href = url;
		link.download = fileName;
		document.body.appendChild(link);
		link.click();

		setTimeout(() => {
			link.remove();
			URL.revokeObjectURL(url);
		}, 1);
	}
	catch(err) {
		if (err instanceof SyntaxError) {
			m = err.toString().match(/line (\d+)/i);
			if (m) {
				gotoLine(parseInt(m[1]));
				return setTimeout(onError, 1, err);
			}
			else {
				let m = err.toString().match(/position (\d+)/i);
				if (m) {
					let position = parseInt(m[1]);
					let line = plainView.innerText.slice(0,position).match(/\n/g).length + 1;
					gotoLine(line);
					return setTimeout(onError, 1, err);
				}
			}
		}
		onError(err);
	}
}

function gotoLine(lineNum) {
	const rgx = /\n/g;
	while (m = rgx.exec(plainView.innerText)) {
		lineNum--;
		if (lineNum <= 1) {
			let range = document.createRange();
			range.setStart(plainView.childNodes[0], m.index+1);

			if (m = rgx.exec(plainView.innerText))
				range.setEnd(plainView.childNodes[0], m.index);
			else
				range.setEnd(plainView.childNodes[0], plainView.innerText.length);

			window.getSelection().removeAllRanges();
			window.getSelection().addRange(range);

			let posY = range.getBoundingClientRect().top;
			let codeTop = plainView.getBoundingClientRect().top;
			let targetPosY = codeTop + plainView.getBoundingClientRect().height/2;
			console.log(posY, codeTop, targetPosY);
			plainView.scrollBy({
				top: posY - targetPosY,
				left: -plainView.scrollLeft,
				behavior: 'instant',
			});

			break;
		}
	}
}

function mergePropertyTags(source, dest) {
	if (typeof(dest) != typeof(source) && dest !== undefined && source !== undefined)
		throw new Error("Type mismatch for property '"+propName+"' - dest is "+typeof(dest)+" but source is "+typeof(source));

	// Nothing to merge if one of those is true
	if (typeof(dest) != 'object' || typeof(source) != 'object' || !dest || !source)
		return;

	if (dest instanceof Array) {
		if (!(source instanceof Array))
			throw new Error("Type mismatch for property '"+propName+"' - dest is Array but source is Object");

		// NOTE: This is a basic system, will not support significant changes.
		// When it comes to array of structs, the struct items may have varying property tags (since only non-defaults are serialized).
		// If we remove an element from the array, we have no guarantee we'll find the right tags to import from source item at the modified index.
		// Adding an array element that contains reflection data is obviously also not supported by the merger.
		for (let i=0; i<dest.length; i++)
			mergePropertyTags(source[i], dest[i]);
		return;
	}

	if (source instanceof Array)
		throw new Error("Type mismatch for property '"+propName+"' - dest is Object but source is Array");

	const props = TQ2SS.Options.PropertiesKey;
	if (source[props]) {
		let remainingProps = Object.keys(dest);
		dest[props] = [];
		for (let tag of source[props]) {
			// Only add tag if present in destination
			if (dest[tag.Name] !== undefined)
				dest[props].push(tag);

			remainingProps.splice(remainingProps.indexOf(tag.Name), 1);
		}
		if (remainingProps.length > 0)
			throw new Error("Could not find property tag(s) for "+remainingProps.join(", "));
	}

	// Recurse
	for (let propName in dest) {
		if (propName != props)
			mergePropertyTags(source[propName], dest[propName]);
	}
}

function onError(err) {
	console.error(err);
	alert(err);
}

</script>

</body>
</html>
